# SPDX-License-Identifier: MIT
---
- name: Set platform/version specific variables
  include_tasks: tasks/set_vars.yml

- name: Fail if role installs openmpi without cuda toolkit
  fail:
    msg:
      - OpenMPI requires CUDA Toolkit to be installed
      - You must set hpc_install_cuda_toolkit to true to install CUDA Toolkit
  when:
    - hpc_install_openmpi
    - not hpc_install_cuda_toolkit

- name: Deploy the GPG key for repositories
  rpm_key:
    key: "{{ item.key }}"
    state: present
  loop:
    - repo_name: RHEL EPEL repository
      key: "{{ __hpc_rhel_epel_rpm_key }}"
    - repo_name: NVIDIA repository
      key: "{{ __hpc_nvidia_rpm_key }}"
    - repo_name: Microsoft Production repository
      key: "{{ __hpc_microsoft_prod_rpm_key }}"
    - repo_name: Microsoft Slurm repository
      key: "{{ __hpc_microsoft_slurm_key }}"

# package dkms is required from this repo
- name: Install EPEL release package
  package:
    name: "{{ __hpc_rhel_epel_rpm }}"
    state: present
    use: "{{ (__hpc_server_is_ostree | d(false)) |
      ternary('ansible.posix.rhel_rpm_ostree', omit) }}"

- name: Configure repositories
  yum_repository:
    name: "{{ item.name }}"
    description: "{{ item.description }}"
    baseurl: "{{ item.baseurl }}"
    gpgcheck: true
  loop:
    - name: nvidia-cuda
      description: NVIDIA CUDA repository
      baseurl: "{{ __hpc_nvidia_cuda_rpm }}"
    - name: microsoft-prod
      description: Microsoft Production Repository
      baseurl: "{{ __hpc_microsoft_prod_rpm }}"
    - name: microsoft-slurm
      description: Microsoft Slurm Repository
      baseurl: "{{ __hpc_microsoft_slurm_rpm }}"

- name: Configure storage
  when: hpc_manage_storage
  block:
    - name: Install lvm2 to get lvs command
      package:
        name: lvm2
        state: present
        use: "{{ (__hpc_server_is_ostree | d(false)) |
          ternary('ansible.posix.rhel_rpm_ostree', omit) }}"

    - name: Get current LV size of {{ hpc_rootlv_name }}
      vars:
        __hpc_lv: /dev/mapper/{{ hpc_rootvg_name }}-{{ hpc_rootlv_name }}
      command: lvs --noheadings --units g --nosuffix -o lv_size {{ __hpc_lv }}
      register: __hpc_rootlv_size_cmd
      changed_when: false

    - name: Get current LV size of {{ hpc_usrlv_name }}
      vars:
        __hpc_lv: /dev/mapper/{{ hpc_rootvg_name }}-{{ hpc_usrlv_name }}
      command: lvs --noheadings --units g --nosuffix -o lv_size {{ __hpc_lv }}
      register: __hpc_usrlv_size_cmd
      changed_when: false

    - name: Configure storage
      include_role:
        name: fedora.linux_system_roles.storage
      vars:
        hpc_rootlv_size_expected: >-
          {{ hpc_rootlv_size | regex_replace('[^0-9]', '') | int }}
        hpc_rootlv_size_curr: "{{ __hpc_rootlv_size_cmd.stdout | int }}"
        __hpc_rootlv_size: >-
          {{ (hpc_rootlv_size_expected | int > hpc_rootlv_size_curr | int)
          | ternary(hpc_rootlv_size, hpc_rootlv_size_curr ~ "G") }}
        hpc_usrlv_size_expected: >-
          {{ hpc_usrlv_size | regex_replace('[^0-9]', '') | int }}
        hpc_usrlv_size_curr: "{{ __hpc_usrlv_size_cmd.stdout | int }}"
        __hpc_usrlv_size: >-
          {{ (hpc_usrlv_size_expected | int > hpc_usrlv_size_curr | int)
          | ternary(hpc_usrlv_size, hpc_usrlv_size_curr ~ "G") }}
        storage_pools:
          - name: "{{ hpc_rootvg_name }}"
            grow_to_fill: true
            volumes:
              - name: "{{ hpc_rootlv_name }}"
                size: "{{ __hpc_rootlv_size }}"
                mount_point: "{{ hpc_rootlv_mount }}"
              - name: "{{ hpc_usrlv_name }}"
                size: "{{ __hpc_usrlv_size }}"
                mount_point: "{{ hpc_usrlv_mount }}"

# # use --nobest to work around broken kernel module update dependencies in base
# # image
# - name: Update packages
#   package:
#     name: "*"
#     state: latest  # noqa package-latest
#     nobest: true
#     use: "{{ (__hpc_server_is_ostree | d(false)) |
#       ternary('ansible.posix.rhel_rpm_ostree', omit) }}"

- name: Force install kernel version
  package:
    name: kernel-{{ __hpc_force_kernel_version }}
    state: present
  when: __hpc_force_kernel_version is not none
  notify: Reboot system

- name: Update kernel
  package:
    name: kernel
    state: latest  # noqa package-latest
  when: __hpc_force_kernel_version is none
  notify: Reboot system

- name: >-
    Explicitly install kernel-devel and kernel-headers packages matching the
    currently running kernel
  package:
    name:
      - kernel-devel-{{ ansible_kernel }}
      - kernel-headers-{{ ansible_kernel }}
    state: present
  notify: Reboot system

- name: Flush handlers to apply new kernel
  meta: flush_handlers

- name: Ensure that dnf-command(versionlock) is installed
  package:
    name: dnf-command(versionlock)
    state: present

- name: Check if kernel versionlock entries exist
  stat:
    path: "{{ __hpc_versionlock_path }}"
  register: __hpc_versionlock_stat

- name: Get content of versionlock file
  command: cat {{ __hpc_versionlock_path }}
  register: __hpc_versionlock_content
  changed_when: false
  when: __hpc_versionlock_stat.stat.exists

# once nvidia drivers are built for a specific kernel version, we need to
# prevent installation of all kernel packages of a different version
# MS unsuccessfully tries to do this in azhpc-images build scripts:
# https://github.com/Azure/azhpc-images/blob/a3f92d283af6c9d11bf08eb0f8763ab67f7c8713/partners/rhel/common/install_utils.sh#L61
- name: Prevent installation of all kernel packages of a different version
  command: dnf versionlock add {{ item }}
  register: __hpc_versionlock_check
  changed_when: true
  when: >-
    not __hpc_versionlock_stat.stat.exists
    or __hpc_versionlock_content.stdout is not search(item  + "-[0-9]")
  loop: "{{ __hpc_versionlock_rpms }}"

- name: Install NVIDIA driver
  package:
    name: "{{ __hpc_nvidia_driver_module }}"
    state: present
    allow_downgrade: true
    use: "{{ (__hpc_server_is_ostree | d(false)) |
      ternary('ansible.posix.rhel_rpm_ostree', omit) }}"
  notify: Reboot system
  # Note that currently the role supports only Microsoft Azure
  # When we add more cloud providers, we need to update this condition
  when: ansible_system_vendor == "Microsoft Corporation"

- name: Install CUDA driver and enable nvidia-persistenced.service
  when:
    - ansible_system_vendor == "Microsoft Corporation"
    - hpc_install_cuda_driver
  block:
    - name: Install CUDA driver
      package:
        name: "{{ __hpc_cuda_driver_packages }}"
        state: present
        use: "{{ (__hpc_server_is_ostree | d(false)) |
          ternary('ansible.posix.rhel_rpm_ostree', omit) }}"

    - name: Enable nvidia-persistenced.service
      service:
        name: nvidia-persistenced.service
        enabled: true

- name: Install CUDA Toolkit
  when:
    - hpc_install_cuda_toolkit
    - ansible_system_vendor == "Microsoft Corporation"
  package:
    name: "{{ __hpc_cuda_toolkit_packages }}"
    state: present
    allow_downgrade: true
    use: "{{ (__hpc_server_is_ostree | d(false)) |
      ternary('ansible.posix.rhel_rpm_ostree', omit) }}"
  register: __hpc_install_cuda_toolkit
  until: __hpc_install_cuda_toolkit is success

- name: Install NVIDIA NCCL
  when: hpc_install_hpc_nvidia_nccl
  package:
    name: "{{ __hpc_nvidia_nccl_packages }}"
    state: present
    allow_downgrade: true
    use: "{{ (__hpc_server_is_ostree | d(false)) |
      ternary('ansible.posix.rhel_rpm_ostree', omit) }}"

- name: Install NVIDIA Fabric Manager and enable service
  when: hpc_install_nvidia_fabric_manager
  block:
    - name: Install NVIDIA Fabric Manager
      package:
        name: "{{ __hpc_nvidia_fabric_manager_packages }}"
        state: present
        use: "{{ (__hpc_server_is_ostree | d(false)) |
          ternary('ansible.posix.rhel_rpm_ostree', omit) }}"

    - name: Ensure that Fabric Manager service is enabled
      service:
        name: nvidia-fabricmanager
        enabled: true

- name: Install RDMA packages
  when: hpc_install_rdma
  block:
    - name: Install RDMA packages
      package:
        name: "{{ __hpc_rdma_packages }}"
        state: present
        use: "{{ (__hpc_server_is_ostree | d(false)) |
          ternary('ansible.posix.rhel_rpm_ostree', omit) }}"

    # azhpc-images build scripts do the same thing here:
    # https://github.com/Azure/azhpc-images/blob/a3f92d283af6c9d11bf08eb0f8763ab67f7c8713/common/install_waagent.sh#L53
    - name: Enable RDMA in waagent configuration
      lineinfile:
        path: /etc/waagent.conf
        line: "OS.EnableRDMA=y"
        create: true
        backup: true
        mode: "0644"
      notify: Restart waagent

- name: Get package facts
  package_facts:
  no_log: true

- name: Install build dependencies
  package:
    name: >-
      {{ __hpc_rpmbuild_packages
      + __hpc_pmix_build_dependencies
      + __hpc_openmpi_build_dependencies }}
    state: present
    use: "{{ (__hpc_server_is_ostree | d(false)) |
      ternary('ansible.posix.rhel_rpm_ostree', omit) }}"

# Must keep the original tarball name because it's hardcoded in hpcx
- name: Set __hpc_hpcx_path fact
  vars:
    hpcx_tarball_basename: "{{ __hpc_hpcx_info.url | basename
      | regex_replace('\\.[^.]*$', '') }}"
  set_fact:
    __hpc_hpcx_path: "{{ __hpc_install_prefix }}/{{ hpcx_tarball_basename }}"

- name: Set facts for building hpcx and openmpi
  set_fact:
    __hpc_hpcx_rebuild_path: "{{ __hpc_hpcx_path }}/hpcx-rebuild"
    __hpc_hcoll_path: "{{ __hpc_hpcx_path }}/hcoll"
    __hpc_ucx_path: "{{ __hpc_hpcx_path }}/ucx"
    __hpc_ucc_path: "{{ __hpc_hpcx_path }}/ucc"
    __hpc_pmix_path: "{{ __hpc_install_prefix }}/{{__hpc_pmix_info.name }}/{{ __hpc_pmix_info.version }}"
    __hpc_openmpi_path: "{{ __hpc_install_prefix }}/{{ __hpc_openmpi_info.name }}-{{ __hpc_openmpi_info.version }}"
    __hpc_cuda_path: /usr/local/cuda

- name: Get stat of pmix path
  stat:
    path: "{{ __hpc_pmix_path }}/bin/pmixcc"
  register: __hpc_pmix_path_stat

- name: Download and build PMIx
  when: not __hpc_pmix_path_stat.stat.exists
  block:
    - name: Download PMIx
      include_tasks: tasks/download_extract_package.yml
      vars:
        __hpc_pkg_info: "{{ __hpc_pmix_info }}"

    - name: Build PMIx
      command:
        cmd: "{{ item }}"
        chdir: "{{ __hpc_pkg_extracted.path }}"
      changed_when: true
      loop:
        - >-
          ./configure --prefix={{ __hpc_pmix_path }}
          --enable-pmix-binaries
          --disable-dependency-tracking
        - make -j {{ ansible_processor_nproc }}
        - make install

- name: Ensure PMIx modulefile directory exists
  file:
    path: "{{ __hpc_module_dir }}/pmix"
    state: directory
    owner: root
    group: root
    mode: '0755'

# The openmpi-{{ __hpc_openmpi_info.version }} env module depends on this
- name: Install PMIx modulefile
  template:
    src: pmix-ver.lua.j2
    dest: "{{ __hpc_module_dir }}/pmix/pmix-{{ __hpc_pmix_info.version }}.lua"
    owner: root
    group: root
    mode: '0644'

- name: Install gdrcopy packages
  vars:
    gdrcopy_version: "{{ __hpc_gdrcopy_info.version | split('-') | first }}"
  when: >-
    (ansible_facts.packages.gdrcopy is not defined
    or ansible_facts.packages.gdrcopy[0].version != gdrcopy_version )
    or (ansible_facts.packages["gdrcopy-kmod"] is not defined
    or ansible_facts.packages["gdrcopy-kmod"][0].version != gdrcopy_version)
    or (ansible_facts.packages["gdrcopy-devel"] is not defined
    or ansible_facts.packages["gdrcopy-devel"][0].version != gdrcopy_version)
  block:
    - name: Download gdrcopy
      include_tasks: tasks/download_extract_package.yml
      vars:
        __hpc_pkg_info: "{{ __hpc_gdrcopy_info }}"

    # Using shell instead of command to support the use of environment variables
    - name: Build gdrcopy RPM packages
      shell:  # noqa command-instead-of-shell
        cmd: CUDA={{ __hpc_cuda_path }} packages/build-rpm-packages.sh
        chdir: "{{ __hpc_pkg_extracted.path }}"
      changed_when: true

    - name: Install packages from built rpms for {{ __hpc_gdrcopy_info.name }}
      package:
        name:
          - "{{ __hpc_pkg_extracted.path }}/gdrcopy-kmod-{{ __hpc_gdrcopy_info.version }}dkms.{{ __hpc_gdrcopy_info.distribution }}.noarch.rpm"
          - "{{ __hpc_pkg_extracted.path }}/gdrcopy-{{ __hpc_gdrcopy_info.version }}.{{ __hpc_gdrcopy_info.distribution }}.x86_64.rpm"
          - "{{ __hpc_pkg_extracted.path }}/gdrcopy-devel-{{ __hpc_gdrcopy_info.version }}.{{ __hpc_gdrcopy_info.distribution }}.noarch.rpm"
        disable_gpg_check: true
        state: present
        use: "{{ (__hpc_server_is_ostree | d(false)) |
          ternary('ansible.posix.rhel_rpm_ostree', omit) }}"

    - name: Remove extracted tarball
      file:
        path: "{{ __hpc_pkg_extracted.path }}"
        state: absent
      changed_when: false

- name: Get stat of hpcx-rebuild path
  stat:
    path: "{{ __hpc_hpcx_rebuild_path }}"
  register: __hpc_hpcx_rebuild_path_stat

- name: Download and build hpcx
  when: not __hpc_hpcx_rebuild_path_stat.stat.exists
  block:
    - name: Download hpcx
      include_tasks: tasks/download_extract_package.yml
      vars:
        __hpc_pkg_info: "{{ __hpc_hpcx_info }}"

    # Packages are installed in /opt, not "/build-result", so pkgconfig
    # files used by openmpi's cmake configure scripts need to be updated.
    - name: Ensure that pkgconfig files use hpcx_home={{ __hpc_hpcx_path }}
      replace:
        path: "{{ item }}"
        regexp: "/build-result/"
        replace: "{{ __hpc_install_prefix }}/"
        backup: true
      loop:
        - "{{ __hpc_pkg_extracted.path }}/hcoll/lib/pkgconfig/hcoll.pc"
        - "{{ __hpc_pkg_extracted.path }}/ucc/lib/pkgconfig/ucc.pc"
        - "{{ __hpc_pkg_extracted.path }}/ucx/lib/pkgconfig/ucx.pc"

    # the shipped pkgconfig for hcoll only includes -lhcoll. However, this
    # library depends on -locoms, so we have to add that to prevent openmpi
    # from failing to link against libhcoll.
    - name: Update hcoll pkgconfig file to add -locoms parameter
      replace:
        path: "{{ __hpc_pkg_extracted.path }}/hcoll/lib/pkgconfig/hcoll.pc"
        regexp: "-lhcoll"
        replace: "-lhcoll -locoms"
        backup: true

    - name: Copy hpcx to {{ __hpc_hpcx_path }}
      copy:
        src: "{{ __hpc_pkg_extracted.path }}/"
        dest: "{{ __hpc_hpcx_path }}"
        mode: "0755"
        owner: root
        group: root
        remote_src: true

    # Using shell instead of command to support the use of environment variables
    - name: Rebuild hpcx with PMIx
      # noqa command-instead-of-shell
      shell: >-
        CUDA_HOME={{ __hpc_cuda_path }}
        {{ __hpc_hpcx_path }}/utils/hpcx_rebuild.sh
        --with-hcoll
        --cuda
        --rebuild-ucx
        --ompi-extra-config
        '--with-pmix={{ __hpc_pmix_path }} --enable-orterun-prefix-by-default'
      changed_when: true

    - name: Copy ompi/tests to hpcx-rebuild
      copy:
        src: "{{ __hpc_hpcx_path }}/ompi/tests/"
        dest: "{{ __hpc_hpcx_rebuild_path }}"
        mode: "0755"
        owner: root
        group: root

    - name: Remove extracted tarball
      file:
        path: "{{ __hpc_pkg_extracted.path }}"
        state: absent
      changed_when: false

- name: Ensure that /etc/lmod directory exists
  file:
    path: /etc/lmod
    state: directory
    owner: root
    group: root
    mode: '0755'

- name: Ensure that /etc/lmod/.modulespath file exists
  file:
    path: /etc/lmod/.modulespath
    state: touch
    owner: root
    group: root
    mode: '0755'

# This requires a new login shell to become visible.
- name: Set up hpcx module files for lmod
  lineinfile:
    path: /etc/lmod/.modulespath
    line: "{{ __hpc_hpcx_rebuild_path }}/modulefiles"
    state: present
    owner: root
    group: root
    mode: '0755'

- name: Get stat of openmpi path
  stat:
    path: "{{ __hpc_openmpi_path }}"
  register: __hpc_openmpi_path_stat

- name: Download and build openmpi
  when: not __hpc_openmpi_path_stat.stat.exists
  block:
    - name: Download {{ __hpc_openmpi_info.name }}
      include_tasks: tasks/download_extract_package.yml
      vars:
        __hpc_pkg_info: "{{ __hpc_openmpi_info }}"

    - name: Build {{ __hpc_openmpi_info.name }}
      command:
        cmd: "{{ item }}"
        chdir: "{{ __hpc_pkg_extracted.path }}"
      changed_when: true
      loop:
        - >-
          ./configure --prefix={{ __hpc_openmpi_path }}
          --with-ucx={{ __hpc_ucx_path }}
          --with-ucc={{ __hpc_ucc_path }}
          --with-hcoll={{ __hpc_hcoll_path }}
          --with-pmix={{ __hpc_pmix_path }}
          --enable-prte-prefix-by-default
          --with-platform=contrib/platform/mellanox/optimized
          --with-cuda={{ __hpc_cuda_path }}
        - make -j {{ ansible_processor_nproc }}
        - make install

    - name: Remove extracted tarball
      file:
        path: "{{ __hpc_pkg_extracted.path }}"
        state: absent
      changed_when: false

- name: Ensure MPI modulefile directory exists
  file:
    path: "{{ __hpc_module_dir }}/mpi"
    state: directory
    owner: root
    group: root
    mode: '0755'

# The openmpi-{{ __hpc_openmpi_info.version }} env module depends on this
- name: Install OpenMPI modulefile
  template:
    src: openmpi-ver.lua.j2
    dest: "{{ __hpc_module_dir }}/mpi/openmpi-{{ __hpc_openmpi_info.version }}.lua"
    owner: root
    group: root
    mode: '0644'

- name: Let user's applications lock as much memory as they need
  lineinfile:
    path: /etc/security/limits.conf
    line: "{{ item }}"
    create: true
    backup: true
    mode: "0644"
  loop:
    - "* soft memlock unlimited"
    - "* hard memlock unlimited"

# - name: Remove build dependencies
#   package:
#     name: "{{ __hpc_rpmbuild_packages }}"
#     state: absent
#     use: "{{ (__hpc_server_is_ostree | d(false)) |
#       ternary('ansible.posix.rhel_rpm_ostree', omit) }}"

- name: Clean dnf cache
  command: dnf clean all
  changed_when: false
